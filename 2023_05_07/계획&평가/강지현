===============================================================================================================================================
5월 7일 (요일)

1) 1764 듣보잡
- 이 문제는 듣도 못한 사람의 명단과 보도 못한 사람의 명단을 입력하고 두 개의 명단에 공통적으로 들어가는 듣도 보도 못한 사람을
- 사전순으로 정렬해서 출력하는 문제이다. c++을 사용하여 문제를 풀었는데 string으로 문자를 받아 각각 다중 for문을 사용하여 비교를 하였다.
- 하지만 명단이 각각 50만까지 들어와서인지 시간복잡도 O(n^2)을 사용하여 문제를 해결하려하니 시간초과가 났다. 혼자서 다른 방법이 없는지 고민하다
- 한모코(스터디)에 들어갔다. 다른 사람들의 알고리즘을 나와 비교해보니 Set을 사용하여 문제를 해결한 인원이 다수 있었다.
- 이 문제를 해결하려면 다중 for문으로 하나씩 비교하는게 아닌(시간초과) 다른 알고리즘(Set)을 활용해야 한다는 것을 알 수 있었다.

2) 1680 쓰레기 수거
- 이 문제를 처음 봤을때는 엄청 쉽게 풀릴 것이라고 생각했다. 다만 문제 이해가 되지 않았었는지 예문의 결과값이 내 생각과는 다르게 출력되는 것을 확인하고
- 손으로 직접 그려보면서 결과값이 왜 저렇게 나오는지 확인해봤다. 쓰레기의 양이 용량에 도달했을 때와 그 지점의 쓰레기를 실었을 때 쓰레기차의 용량을 넘게 될 때,
- 더 이상 쓰레기를 실을 지점이 없을 때 쓰레기를 비우러 가는 것인데 여기서 내가 실수한 것은 그 지점의 쓰레기를 실었을 때 쓰레기차의 용량을 넘게 되는 경우이다.
- 이 경우 그 지점에 쓰레기를 실을수 없기 때문에 가지 않고(거리를 더하지않고) 미리 이전(쓰레기장)으로 돌아가는 것으로 처리해주었는데
- 그 지점에 간 뒤(거리를 더하고) 쓰레기를 확인후에(실지 않고) 이전(쓰레기장)으로 돌아가는 것으로 처리를 해야 이 문제를 해결할 수 있었던 것이다.
- 예문의 결과값 조차 내 생각과 다르기 때문에 문제를 해결하지 못하였지만 스터디를 통하여 문제 이해를 하고 해결할 수있었다.

3) 10815 숫자카드
- 이 문제는 숫자카드를 가지고 있는 카드인지 아닌지를 구별해야하는 문제이다. 출력은 정렬한 결과값으로 나와야 하므로
- std::sort()를 사용하여 정렬하였다. 입력 카드의 갯수가 500000까지 들어오기때문에 단순 for문을 활용하여 구별하면
- 당연히 시간초과가 날것이다. 그래서 나는 이분탐색 방법을 사용해서 문제를 풀었다.
- 첫번째, Left = 0 Right = 카드갯수-1 로 초기화한 후 무한반복문을 사용했다.
- 중앙값 Mid = (Left+Right)/2;로 반복문을 돌리고 만약 중앙값이 찾고자하는 값보다 크면 Right는 중앙값-1
- 중앙값이 찾고자하는 값보다 작으면 Left = 중앙값+1로 비교하는 값을 절반씩 줄이면서 비교해나갔다.
- 중앙값이 찾고자하는 값과 같으면 1 (있는 카드)로 출력하고 만약 Left가 Right보다 커지면 카드가 없다 0을 출력해서
- 프로그램을 종료시켰다. 이 문제를 통하여 이분탐색에 대하여 토론하며 각자 소스를 공유할 수 있었다.

4) 11729 하노이 탑 이동순서
- 이 문제는 재귀문제로 유명한 문제라고 생각이 든다. 이 문제는 재귀함수를 어려워하는 인원이 있어서 스터디하기로 결정했다.
- 처음 hanoi라는 함수를 만들었다 매개변수로는 x,left,mid,right 총 4개를 사용하였는데
- x=(자신보다 작은 원판으로 호출)원판의 갯수 left=이동시작점 mid=잠깐두는자리 right=최종도착지점으로 생각하고 문제를 풀었다.
- 따라서 처음 함수를 호출할때는 (원판의 총 갯수,1,2,3)으로 호출하게 된다.
- 재귀함수는 가장 간단한 경우와 복잡한 경우로 나뉘는데 복잡한 경우 자신보다 작은 수로 다시 본인(함수)를 호출해 나가는 것이다.
- 이 문제에서 가장 간단한 경우는 원판이 하나일때이다. 즉 if(x==1)일때 1번째에 있는 원판이 3번째 있는 곳으로 이동해야하므로 left right를 저장한후 return;해야한다.
- 원판이 1개가 아닌 2개라면 원판하나가 1에서 2로 이동한후 1에서 3으로, 2에서 3으로 이동해야한다. 1에서 3으로 이동하는 것은
- 가장 간단한 경우(원판이 1개일때)사용되므로 hanoi(x-1,left,right,mid); <- 1에서 2로 이동시키고 left와 right를 저장한다.
- 이 후에 hanoi(x-1,mid,left,right); <- 2에서 3으로 이동시킨다. 여기서 함수를 호출할때 cnt변수를 만들어서 하나씩 증가만 시켜주면 된다.
- 갯수와 이동과정(저장해둔 배열)을 main함수에서 출력해주면 이 문제를 해결할수있다.
- 여기서 중요한 것은 이동할 위치를 저장하는 배열, 횟수를 세는 변수는 다 전역변수로 선언해야한다.
