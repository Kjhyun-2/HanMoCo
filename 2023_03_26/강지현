한모코 (백준문제 풀기) 
===============================================================================================================================================
3월 25일 (토요일)

1) 10828 스택
- for문을 사용하여 각각 push,pop,size,empty 경우 if,elif로 처리
- 배열이 비어있으면 -1 출력
- 입력을 받을 때 push 3 한번에 입력 받고 [0]일때 push, [1]일때는 숫자일 수 있도록 split()사용

2) 9012 괄호
- 스택을 응용하여 풀이
- 괄호를 순서대로 입력 받은후 새로운 배열을 만들어 ')' 경우 pop, '(' 경우 새로운 배열에 push.
- 만약 새로운 배열이 비어있는 상태에서 pop이 일어날 경우 -> 열린괄호없이 닫힌괄호만 온 경우 이므로 break
- 새로운 배열의 길이가 0 이면, 정상적인 괄호, 아니면 비정상

3) 2839 설탕배달
- 처음 숫자를 확인 할 때 5로 나누어 떨어지는 경우가 가장 좋기 때문에 if문으로 5로 나누어 떨어지면 n을 5로 나눈 값을 출력
- 처음 5로 나누어 떨어지지 않는 경우 while문에서 n에서 3을 먼저 뺌
- n을 다시 5로 나누어 떨어지는지 비교하고 나누어 떨어지면 5로 나눈 값 + 3을 뺀 횟수 더하여 출력
- 아닐 경우 다시 3을 빼는 while문으로 감

4) 20949 효정과 새 모니터
- 파이썬이 math 라이브러리를 사용하여 제곱과, 제곱근을 계산
- 계산한 값은 dap 배열에 append
- 출력시 큰값이 들어있는 배열의 index를 찾고 먼저 출력

5) 2167 2차원 배열의 합
- 처음 시도했던 방법 ) (i,j) (x,y) 좌표의 위치까지 저장된 수들의 합을 구하는 프로그램이였기 때문에 for문을 x-i,y-j 이중for문을 사용하여 모두 더하면 해결 할 수 있겠다고 생각했으나, 
큰수가 들어가면 시간초과
- 그래서 시도했던 방법이 누적합) 새로운 배열에 (i,j) 자리에는 전의 자리에 있는 숫자들의 합으로 나타냄.
- 누적합배열에서 (i,j)(x,y)에 해당하는 부분에서 겹치는 부분을 제외하면 시간초과없이 해결 가능하다는 것 알게됨

6) 1748 수 이어쓰기1
- 숫자를 모두 나열해서 cnt하면 시간초과.
- 1-9까지는 1자리 , 10-99까지는 2자리  --> 1*1개 2*99 개 ** 이렇게 원하는 숫자까지 더해서 구함

7) 1244 스위치 켜고 끄기
- 여자일 경우 : 뽑은 수의 배수를 찾아 0이면 1로, 1이면 0으로 바꿈, N의 배수이기때문에 for문에 N부터 확인하는것이 시간적으로 절약됨
- 남자일 경우 : 1과 8을 뽑은 경우에는 1,8만 숫자를 바꾸면 됨, 그리고 무슨 수를 뽑았던지 뽑은 수 자리의 숫자는 반대로 바뀌기 때문에 조건문으로 먼저 예외 처리
- 모든 예외를 제외한후, 대칭 위치의 숫자를 비교하며 같으면 바꾸고, 다르면 멈춤

8) 7568 덩치
- 몸무게와 키가 모두 큰 경우를 모든 입력 받은 것과 비교하여 몇개인지 cnt
- cnt한 값을 dap배열에 append한 후 순서대로 출력


===============================================================================================================================================
4월 8일 (토요일)

1) 1817 짐 챙기는 숌
- 첫 번째 입력값(책의 개수)이 0이면 0출력하고 프로그램종료처리
- 배열로 입력받아 각각의 무게를 더하는 hap 변수 사용 (hap이 박스에 책을 담을수 있는 무게보다 작을 때 까지 더함)
- 새로운 check배열을 만들어 박스에 책을 담았는지 확인 (안담겨진 책이 있으면 박스 갯수를 세는 변수 n++)

2) 5635 생일
- pair<pair<string,int>,pair<int,int> >를 사용하여 입력
- std::sort를 통해 정렬 (정렬 기준을 second.second가 같지않으면 내림차순 정렬 만약 같으면 second.first 다시 비교,
- scond.first가 다르면 내림차순 정렬 같으면 first.second비교 최종적으로 first.second를 서로 비교해서 pair 전체를
- 한묶음으로 정렬해서 first.first 즉 이름을 출력

3) 14494 다이나믹이 뭐예요?
- 다이나믹을 사용하기 위한 이차원 배열 dy[1000][1000]; 선언
- dy[0][0] = 1로 초기화
- 구하고자하는 x,y좌표를 입력 (x,y)를 가는 법은 아래,오른쪽,오른쪽대각선 3가지 경우이므로 
  dy[i-1][j]+dy[i][j-1]+dy[i-1][j-1]를 통해 배열 값에 i,j좌표로 갈수 있는 경우의 수를 저장
- 1000000007로 나눈 나머지를 출력

4) 11656 접미사 배
- string으로 a입력 a길이를 k변수에 저장
- char형의 2차원 배열안에 a[0]~k a[1]~k, a[2]~k ... a[k-1]을 저장
- 다중for문 + 무한for문을 사용하여 첫번째 글자를 각각 비교 만약 같으면 두번째,세번째... 다르면 (현재 비교하는 값이 다음값보다 크면) for문을 사용하여 char 문자 전체를
  정렬 그다음 break; 다르면 정렬 필요없이 바로 break; 를 통해 무한for문을 나옴
- 마지막에 char형의 2차원 배열 

