1735
- StringTokenizer를 이용하여 분자와 분모를 한 줄로 받아온 뒤 각각 son배열과 mom배열에 나누어서 대입해준다.
- 분모끼리 곱하여 분모를 같게 만들어준 뒤 분자도 각각 해당하는 분모와 곱하여 더해준다.
- 분모와 분자의 최대공약수를 구한 뒤 분자와 분모에 나눠준다.
- >>>>>
- while문을 이용하여 2씩 나눠보면서 약수를 하나하나 구하는 방법을 사용했더니, 시간초과가 났다.
- 유클리드 호제법을 이용하여 문제를 풀어야 시간초과를 피할 수 있다.
- 분모 = 분모를 분자로 나눈 나머지 
- 분모값이 나왔으면 분자와 분모의 위치를 바꿔서 분모를 분자로, 분자를 분모로 바꿔준다.
- 분모가 0이 될때까지 시행한 후 분모가 0이 되었을때의 분자값이 최대공약수이다.


1010
- 이 문제의 경우는 확률과 통계의 조합을 이용해야 한다. 문제에 앞서 두가지 성질을 먼저 소개하겠다.
- 1. n+1 C r+1 = n C r + n C r+1
- 2. n C 0 = n C n = 1
- 이 두가지 성질을 이용하여 문제를 풀어나갔다.
- 행이 30 열이 30인 이차원배열을 만들어준다.
- for문을 이용하여 I, i와 i, 0자리에 1을 넣어준다.(2번성질 -> n == r, r == 0의 경우는 1이다.)
- for문을 이용하여 1번성질에 맞는 수식을 배열에 대입해준다.(코드참고)
- M개 중에서 N개를 뽑는 경우의 수 이므로 for문을 이용해서 배열의 M, N위치에 있는 값을 출력해주는 작업을 T번 반복해준다.

1049
- StringTokenizer를 이용하여 N과 M을 입력받아온뒤, 하나씩 대입해준다.
- for문을 이용하여 6개자리 팩과 낱개 기타줄을 배열에 넣어준다.
- Arrays 라이브러리를 이용하여 팩(many), 낱개(one)배열을 오름차순 정렬해준다.
- Math.min(두 수중 작은수 return)을 이용하여 6개짜리 팩으로 사는것이 가장 싼지, 낱개로 모두 사는게 가장 싼지, 6개짜리 팩과 낱개 합쳐서 사는게 가장 싼지 구해준 뒤,  이를 출력해준다.

1205
- StringTokenizer를 이용하여 n, p, newScore를 입력받은뒤, 하나씩 대입해준다.
- n이 0이면 기존에 있던 값이 없으므로 해당 입력값이 1위가 된다.
- 다시한번 StringTokenizer와 ArrayList를 이용하여 랭킹 리스트를 만들어준다.
- 랭킹리스트가 가득 차있고, 입력한 값이 제일 작은값과 같다면 -1을 출력해준다.
- for문을 이용하여 아래 두가지 경우를 계속 비교해준다.
    - 랭킹리스트의 특정 값보다 크거나 같다면 입력값의 순위는 특정값(i번째) + 1위가 된다.
    - 랭킹 리스트의 특정 값보다 작은 경우 순위를 한단계 낮추고 다음 값과 비교한다.
- 정해진 rank가 랭킹 리스트에 들어갈 수 있는 순위이면 rank를 출력하고, 아닌경우 -1을 출력한다.
