(11478) - 실버
- 문자열을 i개씩 잘라서 배열에 저장해준다. (1회 : a, b, a, b, c / 2회 : ab, ba, ab, bc / ...)
- 넣을때마다 cnt++해주고, for문과 equals()함수를 이용하여 같은 문자가 있을경우 cnt--해준다.

(1094) - 실버
- 소세지가 원하는 길이보다 크면 반으로 쪼개고
- 자른 소세지가 원하는 길이보다 작으면 cnt++해서 몇번 붙였는지 체크해준다.
- 원하는 길이에서 붙인 소세지만큼 빼준다.
- 이 행위를 while을 이용해서 소세지가 0이 될때까지 반복해준다.

(11047) - 실버
- 동전의 가치를 배열에 넣어주기
- 가장 큰 동전부터 탐색해서 필요한 금액보다 동전이 작아지는 경우에ex) 4200-> 1000
- 필요한 금액을 가장 큰 동전으로 나눈다.-> 몇개 사용되는지.
- 필요한 금액에서 그 값을(4000) 빼주고, while을 이용하여 필요한 금액이
- 0이 될때까지 반복한다.

(1011) - 골드5
- 저번 다이나믹 문제처럼 직접 그림을 그려 규칙을 찾아보면 훨씬 쉽게 풀린다.
 - 거리 : dis, 이동횟수 : cnt, 최댓값 : max
 - max가 1씩 증가하면서 2번씩 반복되는것을 알 수 있고,
 - dis는 이전 거리와 최댓값과의 차이가 max가 증가하는 규칙과 동일하다.
 - max가 변하는 곳의 dis는 max의 제곱이다. -> dis의 루트값에서 소수점을 버린 정수값
 - (int)로 형변환을 시켜주고, Math.sqrt()함수를 활용한다.
 - x와 y를 입력받고 그 사이 거리를 dis변수에 넣어준다.
 - 위 규칙을 토대로 if문을 사용하여 코드를 작성한다.
