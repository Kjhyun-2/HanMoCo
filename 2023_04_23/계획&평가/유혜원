1. 서로 다른 부분 문자열의 개수_11478
 - 난이도 : silver 3
 - hashset 사용
 - substring을 통해 j부터 j+1까지 해당 문자열을 string변수에 더해준다.
 - 문자열 길이만큼의 내부 for문이 종료되면 string을 초기화해준 뒤 반복한다.
 - hash.size 메소드를 통해 길이를 출력한다. 

2. 막대기_1094
 - 난이도 : silver 5
 - 막대 개수(cnt)는 0으로, 막대 길이(stick)는 64로 초기화한다.
 - X가 0이상일 때 stick이 X보다 클 경우, 반으로 나누어주고,
 - stick이 X보다 작을 경우 cnt++을 하고 X 에서 막대 길이를 빼준다.
 - 이 과정을 반복한 후 cnt를 출력한다.
 
 3. Fly me to the Aplha Centauri_1011
 - 난이도 : gold 5
 - 최대 경우는 거리의 제곱근에서 소수점을 뺀 값이다. 이때의 최대 경우를 max라는 변수에 넣는다.
 - 첫번째 경우 ) max와 거리의 제곱근의 값이 같다면 max*2-1 의 값을 출력한다.
 - 위 경우를 제외하고 그 사이의 값들 중에서 규칙을 찾아보면 최대경우 수 만큼 횟수가 2번 반복되는 것을 알 수 있다.
 - 두번째 경우 ) 2번 반복되는 것 중 앞의 경우 즉, max*max보다 크고 max*max - max의 경우와 같거나 작을 때는 max*2를 출력한다.
 - 세번째 경우 ) 2번 반복되는 것 중 뒤의 경우, max*2+1을 출력한다.
 
 4. 동전_11047
 - 난이도 : silver 4
 - 동전의 가치는 차례대로 arr배열에 입력받는다.
 - 배열의 맨뒤(제일 큰 수)부터 0번째 인덱스(제일 작은 수) 순서로 비교한다.
 - 금액이 해당 배열 값보다 작을 경우, 금액과 해당 배열 값을 나눈 몫은 개수에 플러스하고 나머지는 금액으로 한다.
 - 금액이 0이 될때까지 반복한다.  
